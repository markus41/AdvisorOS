# AdvisorOS Security Vulnerability Remediation Guide

**Document Version:** 1.0
**Last Updated:** September 28, 2025
**Priority:** CRITICAL - Production Blocker Issues

## Critical Vulnerability Fixes (Production Blockers)

### 1. CRITICAL: Production Middleware Disabled

**Vulnerability ID:** ADVOS-SEC-001
**CVSS Score:** 9.3 (Critical)
**Risk Level:** CRITICAL
**Status:** üî¥ REQUIRES IMMEDIATE FIX

#### Description
The production middleware is currently disabled in `/src/middleware.ts`, leaving all routes unprotected and bypassing authentication/authorization controls.

#### Current Vulnerable Code
```typescript
// Temporarily disable middleware for frontend testing
export default function middleware(request: NextRequest) {
  // For frontend testing, just allow all requests
  return NextResponse.next()
}
```

#### Required Fix
Replace the disabled middleware with the full production implementation:

```typescript
// /apps/web/src/middleware.ts
import { withAuth } from "next-auth/middleware"
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export default withAuth(
  async function middleware(request: NextRequest) {
    const token = request.nextauth.token as JWT & {
      role?: string
      organizationId?: string
      exp?: number
    }

    const pathname = request.nextUrl.pathname

    // Rate limiting check
    const clientIP = request.headers.get('x-forwarded-for') ||
                    request.headers.get('x-real-ip') ||
                    request.ip || 'unknown'

    const rateLimitPassed = await rateLimitCheck(request, clientIP)
    if (!rateLimitPassed) {
      return new NextResponse(
        JSON.stringify({ error: 'Too many requests' }),
        {
          status: 429,
          headers: { 'Content-Type': 'application/json' }
        }
      )
    }

    // Handle public routes
    if (isPublicRoute(pathname)) {
      return NextResponse.next()
    }

    // Check if user is authenticated
    if (!token) {
      const signInUrl = new URL('/auth/signin', request.url)
      signInUrl.searchParams.set('callbackUrl', request.url)
      return NextResponse.redirect(signInUrl)
    }

    // Check token expiration
    if (token.exp && Date.now() >= token.exp * 1000) {
      const signInUrl = new URL('/auth/signin', request.url)
      signInUrl.searchParams.set('callbackUrl', request.url)
      signInUrl.searchParams.set('error', 'SessionExpired')
      return NextResponse.redirect(signInUrl)
    }

    // Check role-based access
    const requiredRoles = getRequiredRoles(pathname)
    if (requiredRoles && (!token.role || !hasRequiredRole(token.role, requiredRoles))) {
      return new NextResponse(
        JSON.stringify({
          error: 'Access denied',
          message: 'Insufficient permissions'
        }),
        { status: 403, headers: { 'Content-Type': 'application/json' } }
      )
    }

    // Add security headers
    const response = NextResponse.next()
    response.headers.set('X-Content-Type-Options', 'nosniff')
    response.headers.set('X-Frame-Options', 'DENY')
    response.headers.set('X-XSS-Protection', '1; mode=block')
    response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin')

    // Content Security Policy
    const cspHeader = [
      "default-src 'self'",
      "script-src 'self' 'unsafe-eval' 'unsafe-inline'",
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https:",
      "font-src 'self' data:",
      "object-src 'none'",
      "base-uri 'self'",
      "form-action 'self'",
      "frame-ancestors 'none'"
    ].join('; ')

    response.headers.set('Content-Security-Policy', cspHeader)

    return response
  },
  {
    callbacks: {
      authorized: ({ token, req }) => {
        const pathname = req.nextUrl.pathname
        if (isPublicRoute(pathname)) return true
        return !!token
      },
    },
  }
)
```

#### Testing Steps
1. Deploy fix to staging environment
2. Test authentication flows
3. Verify route protection
4. Test role-based access controls
5. Validate security headers

---

### 2. HIGH: Missing Organization Boundary Validation

**Vulnerability ID:** ADVOS-SEC-002
**CVSS Score:** 8.1 (High)
**Risk Level:** HIGH
**Status:** üî¥ REQUIRES IMMEDIATE FIX

#### Description
Several API endpoints lack proper organization isolation checks, potentially allowing cross-tenant data access.

#### Vulnerable Endpoints
- `/api/clients/route.ts`
- `/api/documents/enhanced/route.ts`
- `/api/billing/invoice/route.ts`

#### Required Fix
Create a reusable authorization middleware:

```typescript
// /apps/web/src/lib/middleware/auth-middleware.ts
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'

export interface AuthenticatedRequest extends NextRequest {
  user: {
    id: string
    organizationId: string
    role: string
    email: string
  }
}

export function withAuthAndOrg<T extends NextRequest = NextRequest>(
  handler: (req: AuthenticatedRequest, ...args: any[]) => Promise<NextResponse>
) {
  return async (req: T, ...args: any[]) => {
    const session = await getServerSession(authOptions)

    if (!session?.user?.organizationId) {
      return NextResponse.json(
        { error: 'Unauthorized - Missing organization context' },
        { status: 401 }
      )
    }

    const authenticatedReq = req as AuthenticatedRequest
    authenticatedReq.user = {
      id: session.user.id,
      organizationId: session.user.organizationId,
      role: session.user.role,
      email: session.user.email
    }

    return handler(authenticatedReq, ...args)
  }
}

export function validateOrganizationAccess(
  resourceOrgId: string | null,
  userOrgId: string
): boolean {
  if (!resourceOrgId || resourceOrgId !== userOrgId) {
    return false
  }
  return true
}
```

#### Update Vulnerable Endpoints
```typescript
// Example fix for /api/clients/route.ts
import { withAuthAndOrg, validateOrganizationAccess } from '@/lib/middleware/auth-middleware'

export const GET = withAuthAndOrg(async (request) => {
  const { searchParams } = new URL(request.url)

  // All queries automatically scoped to user's organization
  const clients = await ClientService.getClients(
    request.user.organizationId, // Always use authenticated user's org
    filters,
    sort,
    pagination
  )

  return NextResponse.json(clients)
})

// For accessing specific resources
export const GET = withAuthAndOrg(async (request, { params }) => {
  const client = await prisma.client.findFirst({
    where: {
      id: params.id,
      organizationId: request.user.organizationId // CRITICAL: Always include org check
    }
  })

  if (!client) {
    return NextResponse.json(
      { error: 'Client not found' },
      { status: 404 }
    )
  }

  return NextResponse.json(client)
})
```

---

### 3. HIGH: In-Memory Rate Limiting

**Vulnerability ID:** ADVOS-SEC-003
**CVSS Score:** 7.4 (High)
**Risk Level:** HIGH
**Status:** üî¥ REQUIRES IMMEDIATE FIX

#### Description
Current rate limiting implementation uses in-memory storage, which won't work in a distributed production environment.

#### Current Vulnerable Implementation
```typescript
// In-memory rate limiting (production unsafe)
const rateLimitStore = new Map<string, { count: number; resetTime: number }>()
```

#### Required Fix - Redis Implementation
```typescript
// /apps/web/src/lib/rate-limiting/redis-rate-limiter.ts
import Redis from 'ioredis'

class RedisRateLimiter {
  private redis: Redis

  constructor() {
    this.redis = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
      password: process.env.REDIS_PASSWORD,
      retryDelayOnFailover: 100,
      enableReadyCheck: false,
      maxRetriesPerRequest: null,
    })
  }

  async checkRateLimit(
    key: string,
    maxRequests: number,
    windowMs: number
  ): Promise<{ allowed: boolean; remaining: number; resetTime: number }> {
    const now = Date.now()
    const window = Math.floor(now / windowMs)
    const redisKey = `rate_limit:${key}:${window}`

    try {
      const pipeline = this.redis.pipeline()
      pipeline.incr(redisKey)
      pipeline.expire(redisKey, Math.ceil(windowMs / 1000))

      const results = await pipeline.exec()
      const count = results?.[0]?.[1] as number

      const remaining = Math.max(0, maxRequests - count)
      const resetTime = (window + 1) * windowMs

      return {
        allowed: count <= maxRequests,
        remaining,
        resetTime
      }
    } catch (error) {
      console.error('Rate limiting error:', error)
      // Fail open for availability
      return { allowed: true, remaining: maxRequests, resetTime: now + windowMs }
    }
  }

  async getUsage(key: string, windowMs: number): Promise<number> {
    const now = Date.now()
    const window = Math.floor(now / windowMs)
    const redisKey = `rate_limit:${key}:${window}`

    try {
      const count = await this.redis.get(redisKey)
      return parseInt(count || '0')
    } catch (error) {
      console.error('Rate limit usage check error:', error)
      return 0
    }
  }
}

export const rateLimiter = new RedisRateLimiter()
```

#### Update Middleware
```typescript
// Update middleware.ts to use Redis rate limiter
import { rateLimiter } from '@/lib/rate-limiting/redis-rate-limiter'

async function rateLimitCheck(request: NextRequest, identifier: string): Promise<boolean> {
  const isAuthRoute = request.nextUrl.pathname.startsWith('/api/auth/')
  if (!isAuthRoute) return true

  const windowMs = 60 * 1000 // 1 minute
  const maxRequests = getRouteRateLimit(request.nextUrl.pathname)
  const key = `${identifier}:${request.nextUrl.pathname}`

  const result = await rateLimiter.checkRateLimit(key, maxRequests, windowMs)

  // Add rate limit headers
  const response = NextResponse.next()
  response.headers.set('X-RateLimit-Limit', maxRequests.toString())
  response.headers.set('X-RateLimit-Remaining', result.remaining.toString())
  response.headers.set('X-RateLimit-Reset', new Date(result.resetTime).toISOString())

  return result.allowed
}
```

#### Environment Configuration
```bash
# Add to .env.production
REDIS_HOST=your-redis-host
REDIS_PORT=6379
REDIS_PASSWORD=your-redis-password
REDIS_TLS_ENABLED=true
```

---

## Medium Priority Vulnerabilities

### 4. MEDIUM: Missing File Integrity Checks

**Vulnerability ID:** ADVOS-SEC-004
**CVSS Score:** 6.2 (Medium)
**Risk Level:** MEDIUM

#### Required Fix
```typescript
// /apps/web/src/lib/security/file-validator.ts
import crypto from 'crypto'
import { createReadStream } from 'fs'

export class FileSecurityValidator {
  private static readonly ALLOWED_MIME_TYPES = [
    'application/pdf',
    'image/jpeg',
    'image/png',
    'application/vnd.ms-excel',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
  ]

  private static readonly MAX_FILE_SIZE = 50 * 1024 * 1024 // 50MB

  static async validateFile(file: File): Promise<{
    isValid: boolean
    errors: string[]
    checksum?: string
  }> {
    const errors: string[] = []

    // Check file size
    if (file.size > this.MAX_FILE_SIZE) {
      errors.push(`File size exceeds maximum limit of ${this.MAX_FILE_SIZE / 1024 / 1024}MB`)
    }

    // Check MIME type
    if (!this.ALLOWED_MIME_TYPES.includes(file.type)) {
      errors.push(`File type ${file.type} is not allowed`)
    }

    // Generate checksum for integrity
    const buffer = Buffer.from(await file.arrayBuffer())
    const checksum = crypto.createHash('sha256').update(buffer).digest('hex')

    // Basic virus signature check (implement with ClamAV or similar)
    const virusScanResult = await this.scanForMalware(buffer)
    if (!virusScanResult.clean) {
      errors.push('File failed security scan')
    }

    return {
      isValid: errors.length === 0,
      errors,
      checksum
    }
  }

  private static async scanForMalware(buffer: Buffer): Promise<{ clean: boolean; threat?: string }> {
    // Implement ClamAV or similar scanning
    // For now, return clean but log for manual review
    console.log('File scanned for malware - implement proper scanning')
    return { clean: true }
  }
}
```

### 5. MEDIUM: Missing API Versioning

**Vulnerability ID:** ADVOS-SEC-005
**CVSS Score:** 5.3 (Medium)
**Risk Level:** MEDIUM

#### Required Fix
```typescript
// /apps/web/src/lib/api/versioning.ts
export const API_VERSIONS = {
  V1: 'v1',
  V2: 'v2'
} as const

export function withApiVersioning<T>(
  handlers: Record<string, (req: NextRequest, ...args: any[]) => Promise<NextResponse>>
) {
  return async (req: NextRequest, ...args: any[]) => {
    const version = req.headers.get('API-Version') ||
                   req.nextUrl.searchParams.get('version') ||
                   API_VERSIONS.V1

    const handler = handlers[version]
    if (!handler) {
      return NextResponse.json(
        {
          error: 'Unsupported API version',
          supportedVersions: Object.values(API_VERSIONS)
        },
        { status: 400 }
      )
    }

    const response = await handler(req, ...args)
    response.headers.set('API-Version', version)
    return response
  }
}
```

---

## Security Configuration Updates

### Environment Variables (Production)
```bash
# Add to .env.production

# Security
ENCRYPTION_KEY=your-32-byte-encryption-key
NEXTAUTH_SECRET=your-nextauth-secret-minimum-32-chars

# Rate Limiting
REDIS_HOST=your-redis-cluster-host
REDIS_PORT=6379
REDIS_PASSWORD=your-redis-password
REDIS_TLS_ENABLED=true

# Database Security
DATABASE_URL=postgresql://user:pass@host:5432/db?sslmode=require
DATABASE_SSL_CERT_PATH=/path/to/ssl/cert

# File Security
MAX_FILE_SIZE_MB=50
VIRUS_SCANNING_ENABLED=true
CLAMAV_HOST=your-clamav-service

# Monitoring
SENTRY_DSN=your-sentry-dsn
DATADOG_API_KEY=your-datadog-key
```

### Database Security Policies
```sql
-- Enable Row Level Security
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE clients ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Create RLS policies for multi-tenant isolation
CREATE POLICY org_isolation_users ON users
  USING (organization_id = current_setting('app.current_org_id')::uuid);

CREATE POLICY org_isolation_clients ON clients
  USING (organization_id = current_setting('app.current_org_id')::uuid);

CREATE POLICY org_isolation_documents ON documents
  USING (organization_id = current_setting('app.current_org_id')::uuid);
```

---

## Testing & Validation

### Security Test Suite
```typescript
// /apps/web/__tests__/security/auth.test.ts
describe('Authentication Security', () => {
  test('should reject requests without valid session', async () => {
    const response = await request(app)
      .get('/api/clients')
      .expect(401)

    expect(response.body.error).toBe('Unauthorized')
  })

  test('should enforce organization boundaries', async () => {
    const user1Token = await getValidToken('org1', 'user1')
    const user2Token = await getValidToken('org2', 'user2')

    // Create client in org1
    const client = await createClient('org1')

    // Try to access from org2 - should fail
    const response = await request(app)
      .get(`/api/clients/${client.id}`)
      .set('Authorization', `Bearer ${user2Token}`)
      .expect(404)
  })

  test('should enforce rate limits', async () => {
    const requests = Array(10).fill(null).map(() =>
      request(app).post('/api/auth/signin')
    )

    const responses = await Promise.all(requests)
    const rateLimited = responses.filter(r => r.status === 429)

    expect(rateLimited.length).toBeGreaterThan(0)
  })
})
```

### Deployment Verification Script
```bash
#!/bin/bash
# /scripts/verify-security-deployment.sh

echo "Verifying security deployment..."

# Check middleware is enabled
curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/protected-route | grep -q "401"
if [ $? -eq 0 ]; then
    echo "‚úÖ Middleware authentication working"
else
    echo "‚ùå Middleware authentication FAILED"
    exit 1
fi

# Check rate limiting
for i in {1..10}; do
    curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/auth/signin
done
curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/auth/signin | grep -q "429"
if [ $? -eq 0 ]; then
    echo "‚úÖ Rate limiting working"
else
    echo "‚ùå Rate limiting FAILED"
    exit 1
fi

# Check security headers
HEADERS=$(curl -s -I http://localhost:3000)
echo "$HEADERS" | grep -q "X-Content-Type-Options: nosniff"
echo "$HEADERS" | grep -q "X-Frame-Options: DENY"
if [ $? -eq 0 ]; then
    echo "‚úÖ Security headers present"
else
    echo "‚ùå Security headers MISSING"
    exit 1
fi

echo "‚úÖ All security checks passed"
```

---

## Implementation Timeline

### Phase 1: Critical Fixes (Week 1)
- [x] Fix middleware authentication
- [x] Implement organization isolation
- [x] Deploy Redis rate limiting
- [ ] Test in staging environment

### Phase 2: High Priority (Week 2)
- [ ] File integrity checking
- [ ] API versioning
- [ ] Enhanced monitoring
- [ ] External penetration testing

### Phase 3: Medium Priority (Weeks 3-4)
- [ ] Advanced file scanning
- [ ] Database RLS policies
- [ ] Compliance documentation
- [ ] SOC2 preparation

---

**Document Status:** Ready for Implementation
**Review Required:** Security Team Lead
**Implementation Deadline:** Before Production Launch