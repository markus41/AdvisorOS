# AdvisorOS Reusable Code Patterns
# Version: 1.0.0
# Last Updated: 2025-09-30

patterns:
  # =============================================================================
  # MULTI-TENANT SECURITY PATTERNS
  # =============================================================================

  multi_tenant_query:
    name: "Multi-Tenant Database Query"
    description: "Always include organizationId in Prisma queries for data isolation"
    category: "security"
    priority: "critical"
    language: "typescript"
    example: |
      // ✅ CORRECT: organizationId filtering
      const clients = await prisma.client.findMany({
        where: {
          organizationId: ctx.organizationId, // REQUIRED
          status: 'active',
        },
        include: {
          engagements: {
            where: {
              organizationId: ctx.organizationId, // REQUIRED on relations too
            },
          },
        },
      });

      // ❌ WRONG: Missing organizationId
      const clients = await prisma.client.findMany({
        where: {
          status: 'active', // SECURITY VULNERABILITY: No org filtering
        },
      });

    when_to_use:
      - "Every Prisma query without exception"
      - "All database reads and writes"
      - "Including related data (joins)"

    security_notes:
      - "Missing organizationId causes cross-tenant data leakage"
      - "Prisma middleware can auto-add but explicit is safer"
      - "Test with multiple organizations to verify isolation"

  trpc_procedure:
    name: "tRPC Procedure with Multi-Tenant Security"
    description: "Standard tRPC procedure pattern with organization context"
    category: "api"
    priority: "high"
    language: "typescript"
    example: |
      import { z } from 'zod';
      import { organizationProcedure } from '~/server/api/trpc';

      // Input validation schema
      export const createClientSchema = z.object({
        businessName: z.string().min(1).max(200),
        primaryContactEmail: z.string().email(),
        taxIdNumber: z.string().optional(),
      });

      export const clientRouter = createTRPCRouter({
        create: organizationProcedure
          .input(createClientSchema)
          .mutation(async ({ ctx, input }) => {
            // ctx.organizationId is automatically available and validated
            const client = await prisma.client.create({
              data: {
                ...input,
                organizationId: ctx.organizationId, // From context
                createdById: ctx.session.user.id,
              },
            });

            // Audit trail
            await createAuditLog({
              action: 'CLIENT_CREATED',
              entityType: 'CLIENT',
              entityId: client.id,
              organizationId: ctx.organizationId,
              userId: ctx.session.user.id,
              details: { clientName: client.businessName },
            });

            return client;
          }),

        getById: organizationProcedure
          .input(z.object({ id: z.string() }))
          .query(async ({ ctx, input }) => {
            const client = await prisma.client.findFirst({
              where: {
                id: input.id,
                organizationId: ctx.organizationId, // Security check
              },
              include: {
                engagements: true,
                documents: true,
              },
            });

            if (!client) {
              throw new TRPCError({
                code: 'NOT_FOUND',
                message: 'Client not found',
              });
            }

            return client;
          }),
      });

    when_to_use:
      - "All new API endpoints"
      - "Always use organizationProcedure (not publicProcedure)"
      - "Add audit trails for sensitive operations"

  prisma_model:
    name: "Prisma Model with Multi-Tenant Support"
    description: "Database model pattern with required organizationId"
    category: "database"
    priority: "critical"
    language: "prisma"
    example: |
      // prisma/schema.prisma
      model Client {
        id             String   @id @default(cuid())
        organizationId String   // REQUIRED: Multi-tenant isolation

        // Business fields
        businessName   String
        taxIdNumber    String?
        email          String

        // Audit fields
        createdAt      DateTime @default(now())
        updatedAt      DateTime @updatedAt
        createdById    String

        // Relations (all include organizationId)
        organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
        createdBy      User         @relation(fields: [createdById], references: [id])
        engagements    Engagement[]
        documents      Document[]

        // Indexes for performance
        @@index([organizationId])
        @@index([organizationId, email])
        @@index([organizationId, createdAt])
      }

    when_to_use:
      - "Every new database model"
      - "Always add organizationId first"
      - "Include audit fields (createdAt, updatedAt, createdById)"

    best_practices:
      - "Use @@index on organizationId for query performance"
      - "Add onDelete: Cascade for automatic cleanup"
      - "Use compound indexes for common query patterns"

  # =============================================================================
  # REACT COMPONENT PATTERNS
  # =============================================================================

  react_component:
    name: "React Component with TypeScript"
    description: "Standard React component pattern with props validation"
    category: "frontend"
    priority: "high"
    language: "typescript"
    example: |
      import { FC } from 'react';
      import { type Client } from '@prisma/client';

      interface ClientCardProps {
        client: Client;
        onEdit?: (client: Client) => void;
        onDelete?: (clientId: string) => void;
        className?: string;
      }

      export const ClientCard: FC<ClientCardProps> = ({
        client,
        onEdit,
        onDelete,
        className = '',
      }) => {
        const handleEdit = () => {
          onEdit?.(client);
        };

        const handleDelete = () => {
          if (confirm(`Delete client ${client.businessName}?`)) {
            onDelete?.(client.id);
          }
        };

        return (
          <div className={`rounded-lg border border-gray-200 p-4 ${className}`}>
            <h3 className="text-lg font-semibold">{client.businessName}</h3>
            <p className="text-sm text-gray-600">{client.email}</p>

            <div className="mt-4 flex gap-2">
              {onEdit && (
                <button
                  onClick={handleEdit}
                  className="rounded bg-blue-500 px-4 py-2 text-white hover:bg-blue-600"
                >
                  Edit
                </button>
              )}
              {onDelete && (
                <button
                  onClick={handleDelete}
                  className="rounded bg-red-500 px-4 py-2 text-white hover:bg-red-600"
                >
                  Delete
                </button>
              )}
            </div>
          </div>
        );
      };

    when_to_use:
      - "All new React components"
      - "Use FC<Props> type annotation"
      - "Define Props interface above component"
      - "Use Tailwind for styling"

  react_hook_form:
    name: "Form with React Hook Form and Zod"
    description: "Type-safe form handling with validation"
    category: "frontend"
    priority: "medium"
    language: "typescript"
    example: |
      import { useForm } from 'react-hook-form';
      import { zodResolver } from '@hookform/resolvers/zod';
      import { z } from 'zod';
      import { api } from '~/utils/api';

      // Schema matches backend validation
      const clientFormSchema = z.object({
        businessName: z.string().min(1, 'Business name is required'),
        email: z.string().email('Invalid email address'),
        taxIdNumber: z.string().optional(),
      });

      type ClientFormData = z.infer<typeof clientFormSchema>;

      export const ClientForm = () => {
        const { register, handleSubmit, formState: { errors } } = useForm<ClientFormData>({
          resolver: zodResolver(clientFormSchema),
        });

        const createClient = api.client.create.useMutation({
          onSuccess: (client) => {
            console.log('Client created:', client);
          },
          onError: (error) => {
            console.error('Failed to create client:', error);
          },
        });

        const onSubmit = (data: ClientFormData) => {
          createClient.mutate(data);
        };

        return (
          <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
            <div>
              <label htmlFor="businessName" className="block text-sm font-medium">
                Business Name *
              </label>
              <input
                {...register('businessName')}
                id="businessName"
                className="mt-1 block w-full rounded-md border p-2"
              />
              {errors.businessName && (
                <p className="mt-1 text-sm text-red-600">{errors.businessName.message}</p>
              )}
            </div>

            <div>
              <label htmlFor="email" className="block text-sm font-medium">
                Email *
              </label>
              <input
                {...register('email')}
                id="email"
                type="email"
                className="mt-1 block w-full rounded-md border p-2"
              />
              {errors.email && (
                <p className="mt-1 text-sm text-red-600">{errors.email.message}</p>
              )}
            </div>

            <button
              type="submit"
              disabled={createClient.isLoading}
              className="rounded bg-blue-500 px-4 py-2 text-white hover:bg-blue-600 disabled:opacity-50"
            >
              {createClient.isLoading ? 'Creating...' : 'Create Client'}
            </button>
          </form>
        );
      };

    when_to_use:
      - "All forms in the application"
      - "Use zodResolver for validation"
      - "Match Zod schemas with backend"

  # =============================================================================
  # SERVICE LAYER PATTERNS
  # =============================================================================

  service_class:
    name: "Service Layer Class"
    description: "Business logic encapsulation in service classes"
    category: "backend"
    priority: "high"
    language: "typescript"
    example: |
      // apps/web/src/server/services/client.service.ts
      import { PrismaClient } from '@prisma/client';
      import { TRPCError } from '@trpc/server';
      import { createAuditLog } from './audit.service';

      export class ClientService {
        constructor(private prisma: PrismaClient) {}

        async createClient(
          data: { businessName: string; email: string; taxIdNumber?: string },
          organizationId: string,
          userId: string
        ) {
          // Validation
          const existing = await this.prisma.client.findFirst({
            where: {
              organizationId,
              email: data.email,
            },
          });

          if (existing) {
            throw new TRPCError({
              code: 'CONFLICT',
              message: 'Client with this email already exists',
            });
          }

          // Create client
          const client = await this.prisma.client.create({
            data: {
              ...data,
              organizationId,
              createdById: userId,
            },
          });

          // Audit trail
          await createAuditLog({
            action: 'CLIENT_CREATED',
            entityType: 'CLIENT',
            entityId: client.id,
            organizationId,
            userId,
            details: { clientName: client.businessName },
          });

          return client;
        }

        async getClientsByOrganization(organizationId: string) {
          return this.prisma.client.findMany({
            where: { organizationId },
            orderBy: { createdAt: 'desc' },
            include: {
              engagements: {
                where: { organizationId },
                take: 5,
                orderBy: { createdAt: 'desc' },
              },
            },
          });
        }

        async updateClient(
          clientId: string,
          data: { businessName?: string; email?: string },
          organizationId: string,
          userId: string
        ) {
          // Verify ownership
          const client = await this.prisma.client.findFirst({
            where: { id: clientId, organizationId },
          });

          if (!client) {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Client not found',
            });
          }

          // Update
          const updated = await this.prisma.client.update({
            where: { id: clientId },
            data,
          });

          // Audit trail
          await createAuditLog({
            action: 'CLIENT_UPDATED',
            entityType: 'CLIENT',
            entityId: clientId,
            organizationId,
            userId,
            details: { changes: data },
          });

          return updated;
        }
      }

    when_to_use:
      - "Complex business logic"
      - "Operations involving multiple models"
      - "Reusable logic across multiple endpoints"

    best_practices:
      - "Always verify organizationId ownership"
      - "Create audit trails for modifications"
      - "Throw TRPCError for user-facing errors"
      - "Use transactions for multi-step operations"

  # =============================================================================
  # TESTING PATTERNS
  # =============================================================================

  unit_test:
    name: "Jest Unit Test Pattern"
    description: "Standard unit test with mocks and assertions"
    category: "testing"
    priority: "high"
    language: "typescript"
    example: |
      // apps/web/__tests__/services/client.service.test.ts
      import { ClientService } from '~/server/services/client.service';
      import { prismaMock } from '../__mocks__/prisma';

      describe('ClientService', () => {
        let service: ClientService;

        beforeEach(() => {
          service = new ClientService(prismaMock);
        });

        describe('createClient', () => {
          it('should create a new client successfully', async () => {
            const mockClient = {
              id: '1',
              businessName: 'Acme Corp',
              email: 'contact@acme.com',
              organizationId: 'org1',
              createdById: 'user1',
              createdAt: new Date(),
              updatedAt: new Date(),
            };

            prismaMock.client.findFirst.mockResolvedValue(null);
            prismaMock.client.create.mockResolvedValue(mockClient);

            const result = await service.createClient(
              {
                businessName: 'Acme Corp',
                email: 'contact@acme.com',
              },
              'org1',
              'user1'
            );

            expect(result).toEqual(mockClient);
            expect(prismaMock.client.create).toHaveBeenCalledWith({
              data: expect.objectContaining({
                businessName: 'Acme Corp',
                email: 'contact@acme.com',
                organizationId: 'org1',
              }),
            });
          });

          it('should throw error if client with email already exists', async () => {
            prismaMock.client.findFirst.mockResolvedValue({
              id: '1',
              email: 'contact@acme.com',
            } as any);

            await expect(
              service.createClient(
                { businessName: 'Acme Corp', email: 'contact@acme.com' },
                'org1',
                'user1'
              )
            ).rejects.toThrow('Client with this email already exists');
          });
        });
      });

    when_to_use:
      - "All service methods"
      - "Complex utility functions"
      - "Business logic validation"

    best_practices:
      - "Mock Prisma client for database operations"
      - "Test both success and error cases"
      - "Use descriptive test names"
      - "Group related tests with describe blocks"

  integration_test:
    name: "Integration Test with Test Database"
    description: "End-to-end test with real database"
    category: "testing"
    priority: "medium"
    language: "typescript"
    example: |
      // apps/web/tests/integration/client-api.test.ts
      import { createTestContext } from '../helpers/test-context';
      import { prisma } from '~/server/db';

      describe('Client API Integration', () => {
        const ctx = createTestContext();

        beforeEach(async () => {
          await ctx.setup();
        });

        afterEach(async () => {
          await ctx.teardown();
        });

        it('should create and retrieve client with proper isolation', async () => {
          // Create client
          const client = await ctx.trpc.client.create({
            businessName: 'Test Corp',
            email: 'test@example.com',
          });

          expect(client).toMatchObject({
            businessName: 'Test Corp',
            email: 'test@example.com',
            organizationId: ctx.organization.id,
          });

          // Retrieve client
          const retrieved = await ctx.trpc.client.getById({ id: client.id });
          expect(retrieved).toMatchObject(client);

          // Verify isolation - different org can't access
          const otherOrgCtx = await createTestContext();
          await otherOrgCtx.setup();

          await expect(
            otherOrgCtx.trpc.client.getById({ id: client.id })
          ).rejects.toThrow('Client not found');

          await otherOrgCtx.teardown();
        });
      });

    when_to_use:
      - "Critical API workflows"
      - "Multi-tenant isolation testing"
      - "Complex database interactions"

  # =============================================================================
  # ERROR HANDLING PATTERNS
  # =============================================================================

  error_handling:
    name: "Comprehensive Error Handling"
    description: "Standard error handling with logging and user messages"
    category: "error-handling"
    priority: "high"
    language: "typescript"
    example: |
      import { TRPCError } from '@trpc/server';
      import { logger } from '~/utils/logger';

      export const processDocument = async (
        documentId: string,
        organizationId: string
      ) => {
        try {
          // Retrieve document
          const document = await prisma.document.findFirst({
            where: { id: documentId, organizationId },
          });

          if (!document) {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Document not found',
            });
          }

          // Process with Azure Form Recognizer
          const result = await formRecognizerClient.beginAnalyzeDocument(
            'prebuilt-invoice',
            document.url
          );

          return result;

        } catch (error) {
          // Log error with context
          logger.error('Document processing failed', {
            documentId,
            organizationId,
            error: error instanceof Error ? error.message : 'Unknown error',
            stack: error instanceof Error ? error.stack : undefined,
          });

          // Re-throw TRPCError as-is
          if (error instanceof TRPCError) {
            throw error;
          }

          // Wrap other errors
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to process document. Please try again.',
            cause: error,
          });
        }
      };

    when_to_use:
      - "All async operations"
      - "External service calls"
      - "Database operations"

    best_practices:
      - "Always log errors with context"
      - "Provide user-friendly messages"
      - "Don't expose sensitive error details to users"
      - "Use appropriate HTTP status codes"

  # =============================================================================
  # AUDIT TRAIL PATTERNS
  # =============================================================================

  audit_trail:
    name: "Comprehensive Audit Trail"
    description: "Required for SOX/GAAP compliance on financial operations"
    category: "compliance"
    priority: "critical"
    language: "typescript"
    example: |
      // apps/web/src/server/services/audit.service.ts
      import { prisma } from '~/server/db';

      export interface AuditLogData {
        action: string;
        entityType: string;
        entityId: string;
        organizationId: string;
        userId: string;
        details?: Record<string, any>;
        ipAddress?: string;
        userAgent?: string;
      }

      export async function createAuditLog(data: AuditLogData) {
        return prisma.auditLog.create({
          data: {
            action: data.action,
            entityType: data.entityType,
            entityId: data.entityId,
            organizationId: data.organizationId,
            userId: data.userId,
            details: data.details || {},
            ipAddress: data.ipAddress,
            userAgent: data.userAgent,
            timestamp: new Date(),
          },
        });
      }

      // Usage in financial operations
      export const updateTaxCalculation = async (
        calculationId: string,
        updates: Partial<TaxCalculation>,
        ctx: Context
      ) => {
        const before = await prisma.taxCalculation.findFirst({
          where: { id: calculationId, organizationId: ctx.organizationId },
        });

        const updated = await prisma.taxCalculation.update({
          where: { id: calculationId },
          data: updates,
        });

        // REQUIRED: Audit trail for financial operations
        await createAuditLog({
          action: 'TAX_CALCULATION_UPDATED',
          entityType: 'TAX_CALCULATION',
          entityId: calculationId,
          organizationId: ctx.organizationId,
          userId: ctx.session.user.id,
          details: {
            before: before,
            after: updated,
            changes: updates,
          },
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers['user-agent'],
        });

        return updated;
      };

    when_to_use:
      - "ALL financial operations (REQUIRED)"
      - "User authentication and authorization events"
      - "Data modifications on sensitive entities"
      - "Permission changes"

    compliance_notes:
      - "Required for SOX Section 404 compliance"
      - "Must be immutable once created"
      - "Retain for minimum 7 years"
      - "Include before/after state for modifications"

meta:
  version: "1.0.0"
  last_updated: "2025-09-30"
  total_patterns: 11
  categories:
    - security
    - api
    - database
    - frontend
    - backend
    - testing
    - error-handling
    - compliance

  usage_instructions: |
    1. Search patterns by category or name
    2. Copy and adapt examples to your specific use case
    3. Always follow security patterns (organizationId filtering)
    4. Test patterns thoroughly before production deployment
    5. Update patterns when better approaches are discovered

  contribution_guidelines: |
    - Add new patterns as they emerge from development
    - Include comprehensive examples with comments
    - Document when_to_use and best_practices
    - Mark priority levels (critical, high, medium, low)
    - Include anti-patterns (what NOT to do)